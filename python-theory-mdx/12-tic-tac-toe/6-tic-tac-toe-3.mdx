Итак, давайте разобьем игру на 6 шагов для лучшей декомпозиции. Интерфейс будет выглядеть, как на картинке ниже.

# 1 Шаг. Планирование

Первым делом нужно подготовить модульную структуру игры. Структура проекта выглядит следующим образом:

![1](https://raw.githubusercontent.com/Codynodycom/library-py-easy/refs/heads/main/python-theory/12-tic-tac-toe/images/1.png)

У нас будет пока 4 модуля:

#### 1) `constants.py` — для хранения статичных данных

Каждый раз при вводе хода, игра должна показывать в терминале кто ходит — крестики или нолики. Также, если вернуться к алгоритму, то можно заметить, что там есть имена игроков. А это значит, что было бы неплохо выводить при каждом вводе хода имя игрока.

![3](https://raw.githubusercontent.com/Codynodycom/library-py-easy/refs/heads/main/python-theory/12-tic-tac-toe/images/3.png)
![4](https://raw.githubusercontent.com/Codynodycom/library-py-easy/refs/heads/main/python-theory/12-tic-tac-toe/images/4.png)
![5](https://raw.githubusercontent.com/Codynodycom/library-py-easy/refs/heads/main/python-theory/12-tic-tac-toe/images/5.png)

Для это задачи очень удобно использовать переменную с динамическим (изменяемым) значением.

```python
TURN_TEXT = '''Пример хода: 1b | 2c | 3a
Ходит игрок {} - {}:
>>>'''
```

Также давайте создадим переменную с подстановкой крестика или нолика при запросе имени вначале игры:

```python
NICKNAME_INPUT = 'Игрок {} введите никнейм: ' 
```

И подготовим константы для проверки корректности хода, выигрыша и вывода игрового поля:

```python
# проверка выигрыша
WIN_LINE_X = ['x', 'x', 'x']
WIN_LINE_O = ['o', 'o', 'o']

# проверка корректности хода
ABC = 'abc'
ABC_NUMS = '123'
EMPTY_CELL = '*'
LETTER_TO_INDEX = {
    'a': 0,
    'b': 1,
    'c': 2,
}

# константы для вывода поля
TOP_FIELD_CELLS = '|   |  a  |  b  |  c  |'
TOP_FIELD_LINE = '╭─────────────────────╮'
MID_FIELD_LINE = '├─────────────────────┤'
BOTTOM_FIELD_LINE = '└─────────────────────┘'
```

**field_module.py** — для функций управления игровым полем.

В этом модуле будет хранится само игровое поле и 3 функции:

**get_field()** — возвращает текущее состояние игрового поля

**show_field()** — вывод игрового поля в терминал

**set_cell_in_field(row, col, player)** — ставит крестик или нолик в игровое поле

Содержимое модуля можно разметить следующим образом:

```python
field = [
    ['*', '*', '*'],
    ['*', '*', '*'],
    ['*', '*', '*'],
]

# Возвращает текущее игровое поле field
def get_field():
    ...

# Выводит в теминал оформленное игровое поле
def show_field():
    ...

def set_cell_in_field(row: int, col: int, player: str):
    """
        функция устанавливает player_value в поле
        row - номер строки
        col - номер столбца
        player_value - значение игрока - Х или О
    """

    ...
```

Причем, обратите внимание, что у аргументов функции set_cell_in_field через : прописаны типы. Это называется **аннотации.** Они создаются для бОльшей читабельности кода, но не ограничивают передачу агрументов других типов. То есть, если у **`row`** будет указн тип **`int`**, а мы вызовем функцию `set_cell_in_field(’hello’, 5, ‘x’)`, то в этом случае ошибки не будет, но при чтение кода возникнет ошибка мышления.

#### 2) `gameplay.py` — для проверки корректности хода и победы игроков

Здесь мы проверяем, корректно ли введен ход, свободна ли запрашиваемая клетка и выиграл ли кто-то из игроков:

```python
# Проверяет, правильно ли введен ход игрока
def check_turn(player_turn: str):
    ...

# Проверяет пустая ли ячейка на игровом поле
def is_cell_free(player_turn: str): # 1a | 2b | 3c
    ...

# Проверяет победителя
def chech_win(player_x: str, player_o: str, field: list):
    ...

```

#### 3) `main.py` — точка входа с главным игровым циклом

Алгоритм работы главного модуля не требует излишнего описания. Давайте разметим его комментариями:

```python
# Подключаем зависимости

# Меняет переменную с текущим игроком O --> X или наоборот
def change_player():
    ...

# START GAME

# Выводим доску лидеров

# Запрашиваем НИК для х
# Запрашиваем НИК для о

# Переменная для текущего игрока. Чередуется после каждого хода

# Переменная для Х или О для текущего игрока

# MAIN GAME LOOP

    # Выводится поле
    
    # Запрос хода (х | о)

    # Проверяем 1-ый и 2-ой символы на правильность

    # Проверяем пустая ли клетка, куда игрок хочет походить

    # Ход игрока

    # Проверка выйгрыша

    # Если кто-то выиграл, то выводим победителя и завершаем игру

    # Смена игрока

# Определяем победителя
    # сохраняем результаты
```
