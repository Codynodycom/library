# 4 Шаг. Проверка побед

Теперь, когда у нас есть логика проверок хода и смены игроков, давайте реализуем систему, которая будет проверять победу после каждого хода. В крестиках-ноликах победителем считается игрок, который сумел выстроить три своих символа по горизонтали, вертикали или диагонали.

### Возможные комбинации для победы

Существует 8 возможных выигрышных комбинаций:

- Три символа в одной строке (3 варианта).

- Три символа в одном столбце (3 варианта).

- Две диагональные линии (2 варианта).

Нам нужно будет проверить каждую из этих комбинаций после каждого хода. Если одна из комбинаций выполнена, значит, у нас есть победитель.

### Реализация проверки победы

Для начала создадим функцию `check_win()`, которая будет принимать текущее игровое поле и проверять наличие выигрышной комбинации.

```python
def check_win(field: list, player_value: str) -> bool:
    """
    Проверяет, есть ли выигрышная комбинация для текущего игрока.
    Возвращает True, если игрок победил.
    """
    # Проверка строк
    for row in field:
        if row == [player_value, player_value, player_value]:
            return True

    # Проверка столбцов
    for col in range(3):
        if field[0][col] == field[1][col] == field[2][col] == player_value:
            return True

    # Проверка диагоналей
    if field[0][0] == field[1][1] == field[2][2] == player_value:
        return True
    if field[0][2] == field[1][1] == field[2][0] == player_value:
        return True

    return False
```

Эта функция проверяет три строки, три столбца и две диагонали на наличие трех одинаковых символов (крестиков или ноликов). Если хоть одна из проверок возвращает True, значит, у нас есть победитель.

### Интеграция проверки победы в основной цикл игры

Теперь, когда у нас есть функция проверки победы, давайте интегрируем её в основной игровой цикл. После каждого хода будем вызывать эту функцию, чтобы убедиться, что кто-то не выиграл.

```python
while True:
    # Выводим игровое поле
    show_field()

    # Запрос хода от текущего игрока
    player_turn = input(TURN_TEXT.format(player_name, player_value)).lower()

    # Проверка правильности ввода
    if not check_turn(player_turn):
        print("Некорректный ввод. Попробуйте снова.")
        continue

    # Проверка, свободна ли клетка
    if not is_cell_free(player_turn, field):
        print("Клетка уже занята. Попробуйте снова.")
        continue

    # Ход игрока
    set_cell_in_field(
        row=int(player_turn[0]) - 1, 
        col=LETTER_TO_INDEX[player_turn[1]], 
        player=player_value
    )

    # Проверка выигрыша
    if check_win(field, player_value):
        show_field()
        print(f"Поздравляем! Победитель: {player_name} ({player_value})")
        break  # Завершаем игру

    # Смена игрока
    change_player()
```

### Обработка ничьей

Также стоит учитывать вариант, когда на поле больше нет свободных клеток, и никто не выиграл. В этом случае игра должна завершиться ничьей. Для этого мы добавим проверку на наличие пустых клеток перед сменой хода.

```python
# Проверка, остались ли пустые клетки
if all(EMPTY_CELL not in row for row in field):
    show_field()
    print("Игра закончилась ничьей!")
    break
```

Теперь цикл будет завершаться не только при победе одного из игроков, но и в случае, если всё поле занято, и ни один игрок не смог выиграть.

На этом этапе мы добавили логику проверки победы и возможность завершения игры ничьей. Теперь игра будет корректно завершаться, как только один из игроков выстроит три символа подряд или если все клетки будут заняты, а победитель не определён.
