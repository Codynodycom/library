# 6 Шаг. Сортировка и обновление списка победителей

Теперь, когда мы реализовали механизм сохранения и загрузки побед, давайте добавим финальные штрихи к игре. На этом этапе мы сфокусируемся на том, как сортировать список победителей, а также убедимся, что обновление списка победителей происходит корректно после каждого матча.

### Сортировка победителей
Как уже упоминалось, игроки на доске лидеров должны быть отсортированы по количеству побед. Мы уже реализовали вывод с сортировкой в 5-м шаге с помощью функции `show_leaderboard()`. Здесь мы сортировали словарь с именами и количеством побед, используя функцию `sorted()`, которая выводила игроков в порядке убывания их достижений.

```python
def show_leaderboard(leaderboard: dict):
    """
    Выводит доску лидеров на экран.
    """
    print("Доска лидеров:")
    for name, wins in sorted(leaderboard.items(), key=lambda item: item[1], reverse=True):
        print(f"{name}: {wins} побед(ы)")
```

### Подведение итогов игры

Теперь давайте добавим функцию, которая будет показывать итоги матча после того, как игра завершится. Эта функция выведет имя победителя и обновит доску лидеров.

```python
def announce_winner(winner: str, leaderboard: dict):
    """
    Выводит информацию о победителе и обновляет доску лидеров.
    """
    print(f"\nПобедитель: {winner}!")
    show_leaderboard(leaderboard)
```

После того, как игра завершится, мы вызываем эту функцию, чтобы игроки увидели обновленную доску лидеров.

### Финальная интеграция в основной игровой цикл

Теперь соберём все части вместе, чтобы игра корректно завершалась, обновляла доску лидеров и выводила результаты. После каждой победы игра обновляет файл с результатами, и в конце игроки могут увидеть свои позиции на доске лидеров.

Вот как это выглядит в основном игровом цикле:

```python
while True:
    # Выводим игровое поле
    show_field()

    # Запрос хода от текущего игрока
    player_turn = input(TURN_TEXT.format(player_name, player_value)).lower()

    # Проверка правильности ввода
    if not check_turn(player_turn):
        print("Некорректный ввод. Попробуйте снова.")
        continue

    # Проверка, свободна ли клетка
    if not is_cell_free(player_turn, field):
        print("Клетка уже занята. Попробуйте снова.")
        continue

    # Ход игрока
    set_cell_in_field(
        row=int(player_turn[0]) - 1, 
        col=LETTER_TO_INDEX[player_turn[1]], 
        player=player_value
    )

    # Проверка выигрыша
    if check_win(field, player_value):
        show_field()
        print(f"Поздравляем! Победитель: {player_name} ({player_value})")

        # Обновляем доску лидеров
        update_leaderboard('leaderboard.txt', leaderboard, player_name)

        # Показываем победителя и обновленную доску лидеров
        announce_winner(player_name, leaderboard)

        break  # Завершаем игру

    # Смена игрока
    change_player()

    # Проверка на ничью
    if all(EMPTY_CELL not in row for row in field):
        show_field()
        print("Игра закончилась ничьей!")
        break
```

## На этом этапе наша игра полностью готова. 

#### Мы реализовали:

- Логику игры с проверками правильности хода.

- Проверку победителей и завершение игры.

- Сохранение и загрузку доски лидеров.

- Обновление результатов после каждого матча и вывод доски лидеров на экран.

Теперь игроки могут соревноваться между собой, видеть свои достижения на доске лидеров и играть сколько угодно раз!

Мы прошли путь от планирования до реализации полноценной консольной игры "**Крестики-нолики**". Этот проект помогает не только развить навыки работы с модулями, файлами и игровыми циклами, но и научиться организовывать код в удобную и структурированную форму. Если вы захотите усложнить игру, можно добавить такие фичи, как игра с компьютером или более сложные игровые режимы.
