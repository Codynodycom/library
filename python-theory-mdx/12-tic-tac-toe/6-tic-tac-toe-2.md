# Концепция и логика игры

### Начало игры

После старта игры, программа выводит нам список игроков и количество их побед. Затем запрашивает имена двух игроков и, только после этого, стартует новую игру.

### Leader Board

Логика построена таким образом, что все игроки и количество их побед хранятся в отдельном текстовом файле. После запуска игры, программа подгружает данные из файла, преобразовывает в читабельный вид и выводит в терминал. Далее игра запрашивает имена двух игроков и запоминает их до самого конца. Чтобы по окончанию игры проверить, если имя победителя есть в текстовом файле, то увеличить количество его побед. А если победителя там еще нет, то добавить его с рекордом в 1 победу.

### Интерфейс

Интерфейс игры включает в себя разметку поля для удобства ввода хода игроками:

Возможные варианты хода: 1a, 1b, 1c, 2a, 2b, 2c, 3a, 3b, 3c.

### Проверки ~~адекватности игрока~~ правильности ввода

Игрок может очепятаться и нам необходимо подумать о том, какие опечатки может сделать игрок. Итак, после того, как игра получила ввод игрока, нужно убедиться, что игрок ввел правильный вариант хода, не abrakadabr’у какую-нибудь. А если он вообще не ввёл ничего (случайно нажал enter)?

Хорошо, допустим, координаты клетки мы получили верные. А если клетка занята? Надо бы и об этом подумать — как проверить, свободна ли клетка, куда игрок хочет походить. Нам же после всех проверок нужно будет менять игрока, который ходит. А если тут будет ошибка, а игра сменит ход крестиков на ход ноликов, крестики пропустят ход, получается… Ошибся? Ну, не расстраивайся. Свезет в другой раз! А пока пусть нолики ходят. Хах!

Окэээй. О проверках мы подумали. А что за смена игрока? Вот крестики походили, а чего и где менять? Об этом немного позже.

### Победа или ход

Пока давайте подумаем о проверке победы. Представьте, вот крестики ввели координаты хода. Затем сработали проверки ввода. Крестик поставился на поле. Ход игрока сменился на нолики.

А в какой момент должна быть проверка выигрыша? Наверное вы уже догадались, что именно после того, как совершился ход, и нужно проверить! А вдруг крестики выиграли? Тогда и не нужно давать ход ноликам. Просто завершим игру и выведем победителя. И сохраним его в список победителей из нашего текстового файла.

### Что в итоге

Мы разобрали логику на довольно поверхностном уровне. Тем не менее, этого достаточно, чтобы приступить к обдумыванию кода и того, в каком модуле какие будут функции. Общий алгоритм игры получится следующий:

1. Запуск
2. Выгрузка победителей и их рекордов из файла
3. Соритировка победителей
4. Вывод таблицы победителей в терминал
5. Запрос имен игроков
6. НАЧАЛО ИГРОВОГО ЦИКЛА
7. Вывод игрового поля
8. Запрос хода игрока
9. Проверки
10. Если что-то не верно, то
    1. перезапускаем цикл
11. Ставим крестик или нолик в поле
12. Если игрок выиграл, то
    1. Выводим победителя
    2. Прерываем цикл
13. Меняем игрока на следующего (крестики на нолики, например)
14. ПОСЛЕ ЦИКЛА
    1. Проверяем есть ли победитель в файле
    2. Если есть, то добавляем ему +1
    3. Если нет, то добавляем его в самый низ

Не густо получилось. Давайте напишем код и разберем встречающиеся ошибки. Итак, время практики! Юху!
