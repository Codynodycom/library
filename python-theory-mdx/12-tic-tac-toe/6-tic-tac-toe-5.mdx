# 3 Шаг. Логика проверок хода игроков

Теперь, когда у нас есть базовая структура игры и возможность делать ходы, нужно позаботиться о проверке правильности ввода игроками. Это поможет избежать ситуаций, когда игрок вводит неверный ход или пытается походить в уже занятую клетку.

### Проверка правильности ввода хода

Во-первых, необходимо убедиться, что игрок ввел корректные координаты хода. Они должны соответствовать формату, который мы задали, — это комбинация цифры и буквы (например, `1a`, `2b`, `3c`). Для этого мы будем проверять:

- Что первый символ — это цифра от `1` до `3`.
- Что второй символ — это буква a, `b` или `c`.

Мы можем реализовать эту логику в функции `check_turn()`

```python
def check_turn(player_turn: str):
    """
    Проверяет корректность хода игрока.
    Ход должен быть формата: цифра (1, 2, 3) и буква (a, b, c)
    """
    if len(player_turn) != 2:
        return False

    if player_turn[0] not in '123':
        return False

    if player_turn[1] not in 'abc':
        return False

    return True
```

### Проверка, свободна ли клетка

Следующим шагом необходимо проверить, не занята ли клетка, в которую игрок хочет поставить свой крестик или нолик. Мы будем использовать информацию о текущем состоянии игрового поля и проверять, соответствует ли выбранная клетка значению, которое обозначает пустую клетку (в нашем случае это `'*'`).

```python
def is_cell_free(player_turn: str, field: list):
    """
    Проверяет, свободна ли клетка, куда хочет походить игрок.
    Возвращает True, если клетка свободна, иначе False.
    """
    row = int(player_turn[0]) - 1  # Преобразуем строку в индекс
    col = LETTER_TO_INDEX[player_turn[1]]  # Преобразуем букву в индекс

    if field[row][col] == EMPTY_CELL:
        return True
    return False
```

### Применение проверок в игровом цикле

Теперь, когда у нас есть функции для проверки хода, давайте интегрируем их в основной игровой цикл. Нам нужно убедиться, что перед каждым ходом игрока мы проверяем корректность ввода и свободна ли клетка.

```python
while True:
    # Выводим игровое поле
    show_field()

    # Запрос хода от текущего игрока
    player_turn = input(TURN_TEXT.format(player_name, player_value)).lower()

    # Проверка правильности ввода
    if not check_turn(player_turn):
        print("Некорректный ввод. Попробуйте снова.")
        continue

    # Проверка, свободна ли клетка
    if not is_cell_free(player_turn, field):
        print("Клетка уже занята. Попробуйте снова.")
        continue

    # Ход игрока
    set_cell_in_field(
        row=int(player_turn[0]) - 1, 
        col=LETTER_TO_INDEX[player_turn[1]], 
        player=player_value
    )

    # Логика смены игрока и дальнейшего хода
    change_player()
```

### Что в итоге?

На этом этапе мы реализовали логику проверок для предотвращения ошибок ввода и гарантировали, что игроки не могут ходить в занятые клетки. Это помогает поддерживать корректную игру, а также избегать ошибок, которые могли бы привести к некорректному поведению программы.

Теперь можно переходить к следующим шагам — проверке победителей и управлению списком лидеров.
